<div dir="rtl">

# ממ"ן 11

## שאלה 1
### 1. האם צריך לבדוק אם האורך גדול יותר מהרוחב? האם הקוד משתנה אם מתייחסים גם למספרים שליליים
   בשניהם התשובה היא לא

### 2. איך מחשבים את הרדיוסים של המעגלים
   נסביר איך לחשב את הקטרים (כדי למצוא הרדיוס עפ"י הקוטר נשאר רק לחלק ב-2.0 (כדי שלא יהיה חילוק של int)):
* המעגל הפנימי - ערך ה-y של הנקודה השמאלית העליונה פחות ערך ה-y של הנקודה השמאלית התחתונה <br>
* המעגל החיצוני - חישוב (לפי נוסחת המרחק שנמצאת בחוברת הקורס) של המרחק בין הנקודה השמאלית-עליונה לנקודה הימנית-תחתונה

### 3. איך קולטים את הקואורדינטות של הנקודה העליונה בשורה אחת ואת אלה של הנקודה האחרת בשורה שנייה?
   אין צורך ליצור קוד מיוחד. <br>
במקום קליטה ע"י אנטר, נלחץ על מקש הרווח

## שאלה 2

### 1. באיזו שיטה רוצים שנעגל את המספר שיוצא ?
   ליצור קבוע המכיל את הערך 1000.0 (כלומר דאבל) ואז להכפיל את התשובות ללא העיגול בקבוע, לעגל בשיטת round של מחלקת Math ואחרי זה לחלק בקבוע
<div dir="ltr">

```Java
final double MAX = 1000.0;
double afterRound = Math.round(beforeRound * MAX) / MAX;
```

</div>

### 2. איך קולטים ערכים בשורה אחת עם רווחים ?
   אין צורך ליצור קוד מיוחד. <br>
במקום קליטה ע"י אנטר, נלחץ על מקש הרווח

### 3. איך לחשב את התנאים השונים?
  מסתמכים על חוברת הקורס (אנחנו לא נציג את התשובות - אנחנו רק נסביר איך צריך להשתמש בתנאים שנתונים בחוברת כדי לכתוב את התנאי הרצוי): <br>
בתנאי לפתרון יחיד, צריך לבדוק אך ורק אם התנאי המסוים מתקיים ולא כל תנאי נוסף. <br>
במידה והתנאי מעל לא התקיים (רמז: else) אנחנו צריכים לבדוק שני תנאים במקביל (אם למערכת המשוואות יש אינסוף פתרונות, תוצאתם של שני התנאים צריכה להיות true):  <br>
* בתנאי הראשון אין עניין מיוחד. צריך לבדוק **ששני** התת-תנאים (כפי שהם מצוינים בחוברת הקורס) מתקיימים <br>
* ובדיקה נוספת כאשר אנחנו בודקים מצב מסויים **שלא מתקיים** (רמז: !). <br>
רמז נוסף: הדרך לבדוק האם כל אחת מהמשוואות מקיימת את המצב המסוים היא ע"י השוואת המקדמים (a) והתוצאה (b) לערכים מסוימים <br>

אם ענינו על **כל** הדרישות, יש אינסוף פתרונות.  <br>
אם כל התנאים עד עכשיו (של פתרון אחד וכמה פתרונות) לא התקיימו (else),  למערכת אין פתרון.

<br><br><br> <hr>

# ממ"ן 12

## שאלה 1

#### הערכים יכולים להיות שליליים!

### 1. איך בודקים בשיטה של isRight אם הנקודה מצד ימין ?
   כתוב לנו לפי איזה ציר אנחנו משווים <br>
ואז נסתכל על הציור ונבדוק אם ע"פ הציר שצויין הנקודה הימנית יותר <br>
צריכה להיות בעלת ערך ציר חיובי יותר או שלילי יותר <br>

### 2. מה קורה כאשר הנקודה נמצאת באותו מיקום ונפעיל את השיטה isAbove ? <br>
כאשר הנקודות זהות נקבל חזרה את התוצאה false <br>
כאשר הנקודות זהות, אין מישהו שנמצא מעל/מתחת לנקודה ולכן נקבל ביטוי שקר <br>
אותו דבר תקף לגבי כל השיטות של הכיוונים.

## שאלה 2
### 1. צריך לאפשר קבלת ערך שלילי במידות התיבה ? לא רשום לגבי זה כלום
   מזכירים בשני מקומות (בכתיבת הבנאי ובשיטות של set) <br>
מוזכר שאם הערך חייב להיות חיובי ממש

### 2. איך מגיעים לנקודת המרכז של התיבה ?
   הנקודה מורכבת משלושה צירים X Y Z <br>
לכל ציר יש מידה בתיבה שמקבילה לו, נביט באיור שמצורף וננסה להבין <br>
לאחר מכן החישוב יהיה פשוט ביותר,  <br>
בכדי להגיע לנקודת האמצע כנראה שנצטרך לבצע חילוק מסוים, <br>
לבסוף ניקח את נקודת הבסיס ונוסיף/נחסיר(חשוב להבחין בכיוון הציר) את הערכים המתאימים <br>

### 3. כיצד נזיז את התיבה ונחזיר עותק שלה בשיטה move ?
   מקבלים ערכים בשביל להזיז את נקודת הבסיס בשלושת הצירים <br>
את הערכים האלו מוסיפים לנקודת הבסיס base_ <br>
שנמצאת תחת הבוקס (this) <br>
כלומר אפשר פשוט להזיז עם move של Point3D <br>
אבל צריך לעשות את זה באובייקט אחר כדי שהבסיס של התיבה הנוכחית לא ישתנה <br>
אז נעתיק את האובייקט הנוכחי לאובייקט חדש ושם נבצע את הפעולות.


<br><br><br> <hr>

# ממ"ן 13

## שאלה 1

### 1. מה צריך לכלול הבנאי של המחלקה
"בנאי שמאתחל את תכונות המחלקה כך שהמערך יהיה בגודל מקסימלי" <br>
הכוונה היא שאנו צריכים לאתחל את המערך בדרך שלמדנו וע"פ הקבוע שקיבלנו, <br>
בנוסף נצטרך לאפס את המשתנה של מספר התיבות, כי כרגע יצרנו את המערך והוא ריק.

### 2. התייחסות לaddBox
ראשית, מזכירים לנו בתחילת הממ"ן את הדבר הבא: <br>
> התיבות (כלומר האובייקטים מהמחלקה Box3D) נמצאים במערך ברצף, **ללא "חורים" מתחילת המערך**. <br>
המערך צריך להישאר כך (ללא חורים) לאחר כל פעולה. <br>
**התיבות מסודרות במערך לפי גודלן (בנפח)**, **מהקטנה ביותר עד לגדולה ביותר**.

אין צורך למיין את המערך כל פעם מחדש, המטרה בשיטה הזאת היא לדעת כיצד להכניס את הקופסא למקום הנכון. <br>
כלומר, אם קיים לנו מצב מסויים ונצטרך להכניס את התיבה במקום שהוא לא קיצוני,  <br>
נצטרך לפנות מקום במערך ולאחר מכן להכניס את התיבה. <br>
כעת נתפעל מכישורי הצייר שלי: <br>
![דוגמא](https://i.imgur.com/qJCOQw1.png)

### 3. volumeOfSmallestBox
(נכתב על סמך ההבנה שלי מהמטלה והתשובות של והמנחים בפורום) <br>
המטרה בשיטה הזו היא לקבל שני אינדסים שקיימים בתוך המערך, ולמצוא את **הנפח הכי קטן של תיבה שיכולה להכיל את כולן**. <br>
**לא ידוע לנו דבר על האינדקסים** שאנו מקבלים ולכן נצטרך לבדוק מי הקטן מבינהם. <br>
במידה וקיים תא במערך ללא תיבה (NULL), הטווח לא חוקי <br>
כלומר, נניח שיש לנו 3 תיבות: <br>
תיבה 1: אורך 1 רוחב 1 גובה 1 <br>
תיבה 2: אורך 2 רוחב 3 גובה 1 <br>
תיבה 3: אורך 4 רוחב 6 גובה 2 <br>
אז התיבה שתכיל את כולן היא תיבה בעלת המידות: <br>
 אורך 5 רוחב 7 גובה 3, נפח 5 * 7 * 3 <br>
**שימו לב שהתיבה לא נמצאת במערך!** <br>
המסקנה שלנו היא שהמידות הן המפתח לשיטה הזו, אין צורך ליצור אובייקט של תיבה, <br>
אלא להשתמש בידע שלנו על הכלה של תיבות ונצטרך לגלות מה מידות שצריך בכדי שנכיל את כולן.

## שאלה 2

### 1. מה הכוונה בשיטה imageFilterAverage ל8 שכניו ?
הכוונה היא לאיברים שסובבים אותו <br>
כלומר, האיבר האדום הוא האחד שאנו צריכים לשנות <br>
והמסגרת הירוקה היא האיברים שמסביב <br>
לדוגמא: (הדוגמה השמאלית מציגה מקרה קיצון) <br>
![Sample1](https://i.imgur.com/2yq4Dvo.png)
![sample2](https://i.imgur.com/wvZqrE4.png)

<br><br><br> <hr>

# ממ"ן 15

## IntListTwo

### addNumber

![Example](https://i.imgur.com/Unk6Wxu.png) <br>
שאלה קצת טריקית, יש לנו כמה מקרי קצה. <br>
<li>במידה ויש והרשימה ריקה, זה המצב הכי קל ופשוט נוסיף את המספר כnode יחיד ללא קודם וללא הבא, <br>
**שימו לב שהוא ישמש גם כראש וגם כזנב** </li>
<li> כאשר יש לנו איבר אחד, יש לנו שני אופצית, להכניס אותו מלפנים או מאחור <br>
**שימו לב לעדכן גם את הזנב וגם את הראש למקום המתאים** </li>
<li> במידה והמקום המתאים הוא בסוף, שוב נצטרך לבדוק מי הגדול, המספר או הזנב <br> 
ולבצע את השינויים בהתאם </li>
<li> והמקרה הכי פשוט שזה בעצם באמצע הרשימה, קח שרק נעדכן את שני הצדדים </li>
<br>

**הכי חשוב לשים ♥ <br> שמעדכנים גם את האיבר עצמו שהוספנו וגם את האיברים שמצדדיו, אחרת הרשימה מאבדת קישוריות**

### removeNumber

בדומה לaddNumber, יש לנו כמה מקרי קצה <br> 
<li> מקרה ראשון, במידה והרשימה ריקה, אין לנו מה להסיר 🤷 </li>
<li> במידה ולא נמצא מספר שרוצים להסיר, אין לנו מה להסיר 🤷 </li>
<li> אם ישנו רק איבר אחד ברשימה ואותו צריך להסיר, נזכור גם להסיר את הראש והזנב </li>
<li> במידה ונרצה להסיר את הראש, נצטרך לחבר ראש חדש, אחרת הגוף לא יתפקד 😵 </li>
<li> במידה ונרצה להסיר את הזנב, חשוב לחבר זנב חדש 🐊 </li>
<li> והמקרה הכי קליל, במידה ורצה להסיר איבר כלשהו מהרשימה (לא קצה), נדאג לתפור את הקצוות </li>

### readToList
מבקשים מאיתנו לקבל מספרים עד שייקלט מספר 9999- <br>
**שימו לב לא להכניס את המספר 9999- לרשימה** <br>
בשביל יעילות מקסימלית, מומלץ לא להשתמש בשיטה הרגילה של ההוספה.

### length
שיטה פשוטה וקלילה, נעבור על כל האיברים ונצבור אותם במשתנה, על כל איבר, נוסיף 1. <br>
לבסוף נחזיר את המשתנה הנצבר.

### sum
בדומה לlength גם נשתמש במשתנה צובר, אך לערך של הnode - (num). <br>
לבסוף נחזיר את מה שצברנו.

### maxLength
מחווה מדהימה לממ"ן 14, חשבו כיצד ניתן לנצל את זה

### isAverage
ראשית, נחשב את הממוצע של כל הרשימה, ע"י שימוש בתכונות שיש לנו. <br>

<div dir="ltr" >

```Java
int sum = sum(); // שימוש בשיטה שכבר כתבנו, בחרתי להכניס למשנה בשביל שימוש בהמשך
int count = length(); // ע"מ לקבל את מספר האיברים לחילוק
double average = sum / (double)count; // חישוב הממוצע, חשוב לבצע המרה
```

</div>

במידה וקיבלנו את הממוצע שביקשו, ניתן להחזיר true וסיימנו. <br>
במידה ולא, נצטרך למצוא דרך להגיע לממוצע שביקשו מאיתנו. <br>
אני אסביר את ההיגיון ומשם תמשיכו, ניקח את הרשימה הבאה לדוגמה: <br>
6 5 4 3 2 1 <br>
הממוצע שהתבקש הוא: 5 <br>
חישוב הממוצע שלנו כרגע הוא: 3.5 = 6 / 21 <br>
המטרה שלנו היא להגדיל את הממוצע לכיוון 5, לכן אם נחלק מספר גדול יותר לפחות חלקים, הממוצע יגדל, נוריד את 1 מהממוצע ונחשב שוב <br>
כעת נראה שהממוצע שלנו גדל: 4 = 5 / 20 <br>
לכן, כאשר הממוצע שקיבלנו קטן מהממוצע המבוקש נוכל להחסיר מצד שמאל (מכיוון שהרשימה מסודרת בסדר עולה) <br>
וכאשר הממוצע יהיה גדול נחסיר מצד ימין (היכן שנמצאים הערכים הגדולים יותר)

